<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on ryo_n</title><link>https://ryo-n.github.io/tags/programming/</link><description>Recent content in programming on ryo_n</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 16 May 2020 23:16:37 +0900</lastBuildDate><atom:link href="https://ryo-n.github.io/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>CODINGAME SPRING CHALLENGE 2023 参加記</title><link>https://ryo-n.github.io/posts/codingame_fall_challenge_2023/</link><pubDate>Mon, 08 Jan 2024 13:45:57 +0900</pubDate><guid>https://ryo-n.github.io/posts/codingame_fall_challenge_2023/</guid><description>概要 CodinGameに参加したので環境や考察についてまとめる。 最終結果はGold466位で、全体524位でした。
https://www.codingame.com/contests/fall-challenge-2023
環境 VSCode
Rust
ローカル環境とWebIDの同期について 以前は下記拡張を使っていたが、現在では配信も停止しているようだった。 今回は使わず、VSCodeのコードをコピペして提出していた https://www.codingame.com/forum/t/codingame-sync-beta/614
考察 各ドローンを移動させたときの評価値を取り、一番良い評価値の動きを選択する。 全移動を試すと時間切れになってしまうので、下記のように10stepで探索
for dx in (-600..=600).step_by(10) { for dy in (-600..=600).step_by(10) { } } 評価方法 モンスターに食われないようにする visibleの情報と移動先候補の値を利用し、モンスターに食われるようだったら評価値を大幅にマイナスにした 下記実装を利用 https://github.com/CodinGame/FallChallenge2023-SeabedSecurity/blob/main/src/main/java/com/codingame/game/Game.java#L1067
魚に近づくようにする ドローン毎にターゲットの魚6匹ずつを決めておく ターゲットの魚は深くて端のものからリストに追加する レーダーの情報を頼りに、ターゲットの魚のリストの1番目の魚に近づくようにする visibleに入っている場合はレーダー情報ではなくvisibleの情報を利用する 味方ドローンが既にScanしている魚はスキップする 潜るのを優先 魚が真下にいる場合はジグザグ動く挙動になってしまったため、下に潜ることを優先 浮上優先 自ドローンの魚を全部捕まえた場合は浮上優先 ライトつけるかどうか ドローンの深さ周辺に未スキャンのターゲットがいたらライトをつける。魚のtypeから深さを判断。 やりたかったこと 味方ドローンが死んだときにサポートする動作 二機のドローンのレーダー情報を利用して、各魚の位置を大まかに推定 敵がスキャンしていない魚の追い出し 敵の位置を見て、全スキャンしていない状態でも浮上し逃げ切る動作</description></item><item><title>CODINGAME SPRING CHALLENGE 2021 参加記</title><link>https://ryo-n.github.io/posts/codingame_spring_challenge_2021/</link><pubDate>Mon, 17 May 2021 17:14:19 +0900</pubDate><guid>https://ryo-n.github.io/posts/codingame_spring_challenge_2021/</guid><description>はじめに Codingame初参加。
結果はGold Leagueで総合386位だった。
アルゴリズムではPythonを利用しているが、Codingameでは計算量が多そうなイメージだったのでRustで参加。
結果的には手を読んだりするロジックは書いていないのでPythonでも十分だった。
戦術 次の手を読んだりすることなく、与えられたpossible_actionsから強そうな手を選択するという戦術。
選択する際のロジックは下記に列挙する。
COMPLETE &amp;gt; GROW size2の木 &amp;gt; GROW size1の木 &amp;gt; GROW size0の種 &amp;gt; SEED の優先度でアクションをする 同じ日にGROW size2の木 -&amp;gt; COMPLETEとするのと、COMPLETE -&amp;gt; GROW size2の木 とするのでは消費sunポイントが異なる 上記順番でアクションをすると無駄な消費sunポイントを抑えることができる COMPLETEアクションをするかどうかは細かなif文で制御 size3の木が５本以上あった場合 敵にスコア差をつけられていた場合 19日移行、かつスコアに大差をつけていない場合 自分の木の影にならないところにSEEDを撒く 自分の木の影になるところに置くと、6日中2日 自分の木同士が影で妨害しあうことになりsunポイントを稼げなくなってしまうため 自分の木から6方向に2距離伸ばしたcellに対してはSEEDを撒かないようにした 自分の木同士一切かぶらないよう、6方向に3距離伸ばしたcellに対してはSEEDを撒かないようにしたがが弱かった 置ける場所が少なくなるため、、? 敵の木も考慮した方が良かったかもしれない 翌日のsunポイントを最大に受け取れるようCOMPLETE対象を選ぶ COMPLETE対象が複数あった場合、翌日受け取れるsunポイントが最大になる木を選ぶ COMPLETE対象の木を消した盤面を作り、翌日の太陽向きから計算をする 自分が取得するsunポイント - 相手が取得するsunポイントが最大になる木を選ぶ 翌日影になっていてsunポイントをを取得できない、相手の木を影で妨害できていない木が選ばれることとなる 翌日のsunポイントを最大に受け取れるようGROW対象を選ぶ GROW対象が複数あった場合、翌日受け取れるsunポイントが最大になる木を選ぶ GROW対象の木のsizeを増やした盤面を作り、翌日の太陽向きから計算をする 自分が取得するsunポイント - 相手が取得するsunポイントが最大になる木を選ぶ sizeが増えることにより、敵の木を影で妨害できたり、敵の木の影の妨害対象外となる木が選ばれることとなる SEEDは最大1個しか置かないようにする この実装によりSEEDは0sunポイント消費になる size3の木が5本を超えないようにする 5本超えると自分の木同士で影を作り合っている可能性が高いので実装 かなり感覚的なもの 敵にスコア差つけられていたらCOMPLETEをする 序盤のnutrientsの恩恵を敵に回収されないよう実装 序盤 (day5まで) はsize2の木を成長させない これは盤面を見ていてなんとなく入れた実装 終盤ロジック 終盤はGROW size0の種などをしてもCOMPLETEすることができないのでGROWの行動自体停止 GROWしたことによりsunポイントを消費sunポイントより多く獲得できることもあるので改善の余地はあった nutrientsが枯渇している状態はCOMPLETEをしない 状況によっては0スコアしか獲得できないのにCOMPLETEして4sunポイント(1スコア相当)を消費していたりしたので実装 開発環境 CG Local というCodingameが利用しているツールを利用し、ローカルのIDEでコーディングをした。</description></item><item><title>AtCoder Python環境</title><link>https://ryo-n.github.io/posts/atcoder_env_202005/</link><pubDate>Sat, 16 May 2020 23:16:37 +0900</pubDate><guid>https://ryo-n.github.io/posts/atcoder_env_202005/</guid><description>2020年5月段階での自分のAtCoder環境をメモがてら書いておく。 Python環境を想定しているが、AtCoder関連のところは他言語利用者も参考になるかもしれない。 Macを利用している。 質問や分かりにくい点あれば追記するので @ryo_n_code へ。
下記を目指したつもり
コンテストサイト毎の環境を独立 複数マシン(デスクトップとラップトップ等) での利用も容易にする シンプルな操作 サンプルのコピペ操作の排除 サンプルが通らないコードの提出防止 ソースコード管理 github gitを利用してバージョン管理をしている。 githubはプライベートリポジトリも無料で作成できるので、プライベートリポジトリを作成し、 ソースコードファイル、python環境管理ファイル(下記で記述)などもリポジトリ内に保存している。 ディレクトリ構造は下記のようになっている。 コンテスト毎にディレクトリを作成し、コンテストディレクトリの中に各問題ディレクトリが存在している。 各問題ディレクトリの中にソースコードと、testディレクトリが存在し、testディレクトリ内にサンプルが存在する。
$ tree . ├── abc001 │ ├── a │ │ ├── main.py │ │ └── test │ │ ├── sample-1.in │ │ ├── sample-1.out │ │ ├── sample-2.in │ │ ├── sample-2.out │ │ ├── sample-3.in │ │ └── sample-3.out │ ├── b │ │ ├── main.py │ │ └── test │ │ ├── sample-1.</description></item></channel></rss>