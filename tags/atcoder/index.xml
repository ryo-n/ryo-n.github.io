<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>atcoder on ryo_n</title><link>https://ryo-n.github.io/tags/atcoder/</link><description>Recent content in atcoder on ryo_n</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 16 May 2020 23:16:37 +0900</lastBuildDate><atom:link href="https://ryo-n.github.io/tags/atcoder/index.xml" rel="self" type="application/rss+xml"/><item><title>CODINGAME SPRING CHALLENGE 2021 参加記</title><link>https://ryo-n.github.io/posts/codingame_spring_challenge_2021/</link><pubDate>Mon, 17 May 2021 17:14:19 +0900</pubDate><guid>https://ryo-n.github.io/posts/codingame_spring_challenge_2021/</guid><description>はじめに Codingame初参加。
結果はGold Leagueで総合386位だった。
アルゴリズムではPythonを利用しているが、Codingameでは計算量が多そうなイメージだったのでRustで参加。
結果的には手を読んだりするロジックは書いていないのでPythonでも十分だった。
戦術 次の手を読んだりすることなく、与えられたpossible_actionsから強そうな手を選択するという戦術。
選択する際のロジックは下記に列挙する。
COMPLETE &amp;gt; GROW size2の木 &amp;gt; GROW size1の木 &amp;gt; GROW size0の種 &amp;gt; SEED の優先度でアクションをする 同じ日にGROW size2の木 -&amp;gt; COMPLETEとするのと、COMPLETE -&amp;gt; GROW size2の木 とするのでは消費sunポイントが異なる 上記順番でアクションをすると無駄な消費sunポイントを抑えることができる COMPLETEアクションをするかどうかは細かなif文で制御 size3の木が５本以上あった場合 敵にスコア差をつけられていた場合 19日移行、かつスコアに大差をつけていない場合 自分の木の影にならないところにSEEDを撒く 自分の木の影になるところに置くと、6日中2日 自分の木同士が影で妨害しあうことになりsunポイントを稼げなくなってしまうため 自分の木から6方向に2距離伸ばしたcellに対してはSEEDを撒かないようにした 自分の木同士一切かぶらないよう、6方向に3距離伸ばしたcellに対してはSEEDを撒かないようにしたがが弱かった 置ける場所が少なくなるため、、? 敵の木も考慮した方が良かったかもしれない 翌日のsunポイントを最大に受け取れるようCOMPLETE対象を選ぶ COMPLETE対象が複数あった場合、翌日受け取れるsunポイントが最大になる木を選ぶ COMPLETE対象の木を消した盤面を作り、翌日の太陽向きから計算をする 自分が取得するsunポイント - 相手が取得するsunポイントが最大になる木を選ぶ 翌日影になっていてsunポイントをを取得できない、相手の木を影で妨害できていない木が選ばれることとなる 翌日のsunポイントを最大に受け取れるようGROW対象を選ぶ GROW対象が複数あった場合、翌日受け取れるsunポイントが最大になる木を選ぶ GROW対象の木のsizeを増やした盤面を作り、翌日の太陽向きから計算をする 自分が取得するsunポイント - 相手が取得するsunポイントが最大になる木を選ぶ sizeが増えることにより、敵の木を影で妨害できたり、敵の木の影の妨害対象外となる木が選ばれることとなる SEEDは最大1個しか置かないようにする この実装によりSEEDは0sunポイント消費になる size3の木が5本を超えないようにする 5本超えると自分の木同士で影を作り合っている可能性が高いので実装 かなり感覚的なもの 敵にスコア差つけられていたらCOMPLETEをする 序盤のnutrientsの恩恵を敵に回収されないよう実装 序盤 (day5まで) はsize2の木を成長させない これは盤面を見ていてなんとなく入れた実装 終盤ロジック 終盤はGROW size0の種などをしてもCOMPLETEすることができないのでGROWの行動自体停止 GROWしたことによりsunポイントを消費sunポイントより多く獲得できることもあるので改善の余地はあった nutrientsが枯渇している状態はCOMPLETEをしない 状況によっては0スコアしか獲得できないのにCOMPLETEして4sunポイント(1スコア相当)を消費していたりしたので実装 開発環境 CG Local というCodingameが利用しているツールを利用し、ローカルのIDEでコーディングをした。</description></item><item><title>AtCoder Python環境</title><link>https://ryo-n.github.io/posts/atcoder_env_202005/</link><pubDate>Sat, 16 May 2020 23:16:37 +0900</pubDate><guid>https://ryo-n.github.io/posts/atcoder_env_202005/</guid><description>2020年5月段階での自分のAtCoder環境をメモがてら書いておく。 Python環境を想定しているが、AtCoder関連のところは他言語利用者も参考になるかもしれない。 Macを利用している。 質問や分かりにくい点あれば追記するので @ryo_n_code へ。
下記を目指したつもり
コンテストサイト毎の環境を独立 複数マシン(デスクトップとラップトップ等) での利用も容易にする シンプルな操作 サンプルのコピペ操作の排除 サンプルが通らないコードの提出防止 ソースコード管理 github gitを利用してバージョン管理をしている。 githubはプライベートリポジトリも無料で作成できるので、プライベートリポジトリを作成し、 ソースコードファイル、python環境管理ファイル(下記で記述)などもリポジトリ内に保存している。 ディレクトリ構造は下記のようになっている。 コンテスト毎にディレクトリを作成し、コンテストディレクトリの中に各問題ディレクトリが存在している。 各問題ディレクトリの中にソースコードと、testディレクトリが存在し、testディレクトリ内にサンプルが存在する。
$ tree . ├── abc001 │ ├── a │ │ ├── main.py │ │ └── test │ │ ├── sample-1.in │ │ ├── sample-1.out │ │ ├── sample-2.in │ │ ├── sample-2.out │ │ ├── sample-3.in │ │ └── sample-3.out │ ├── b │ │ ├── main.py │ │ └── test │ │ ├── sample-1.</description></item></channel></rss>